"""
Модуль для парсинга и фильтрации логов веб-сервера

Этот модуль предоставляет утилиты для загрузки, парсинга и фильтрации
лог-файлов в JSON формате. Основная функция - итеративная обработка
больших лог-файлов без загрузки всего файла в память.

Функции:
    _try_parse_json(line): Безопасный парсинг JSON строки
    load_lines(files, filter_date): Генератор для чтения и фильтрации логов

Использование:
    from utils.log_parser import load_lines, _try_parse_json

    # Чтение логов с фильтрацией по дате
    lines = list(load_lines(["access.log"], "2024-01-15"))

    # Безопасный парсинг отдельной строки
    parsed_line = _try_parse_json('{"url": "/test", "status": 200}')
"""

import json

def _try_parse_json(line):
    """
     Безопасно парсит JSON строку в объект Python.

     Обрабатывает строку, пытаясь преобразовать её из JSON формата
     в словарь Python. В случае ошибки парсинга возвращает None.

     Args:
         line (str): Строка в JSON формате для парсинга

     Returns:
         dict | None: Распарсенный объект или None при ошибке

     Raises:
         Не поднимает исключений, обрабатывает все ошибки внутри
    """

    try:
        return json.loads(line)
    except Exception:
        # Обрабатываем все возможные ошибки парсинга JSON
        return None


def load_lines(files, filter_date: str | None = None):
    """
    Генератор для чтения и фильтрации лог-файлов.

    Построчно читает один или несколько файлов, применяет фильтрацию
    по дате (если указана) и возвращает строки через генератор.
    Это позволяет обрабатывать большие файлы без загрузки в память.

    Args:
        files (list[str]): Список путей к файлам логов
        filter_date (str | None): Дата для фильтрации в формате YYYY-MM-DD.
                                 Если None - фильтрация не применяется.

    Yields:
        str: Строка лога, прошедшая фильтрацию (если aplicable)

    Raises:
        FileNotFoundError: Если файл не существует
        IOError: Если возникли проблемы с чтением файла

    Notes:
        - Пропускает пустые строки
        - Фильтрация работает только для JSON логов с полем @timestamp
        - Использует кодировку UTF-8 для чтения файлов
        - Работает как генератор для экономии памяти
    """

    # Обрабатываем каждый файл в списке
    for file in files:
        # Открываем файл с указанием кодировки UTF-8
        with open(file, encoding="utf-8") as f:
            # Читаем файл построчно
            for line in f:
                # Пропускаем пустые строки
                if not line.strip():
                    continue

                # Применяем фильтрацию по дате если указана
                if filter_date:
                    # Парсим строку чтобы извлечь timestamp
                    obj = _try_parse_json(line)
                    if obj is None:
                        # Пропускаем строки которые не парсятся как JSON
                        continue

                    # Проверяем наличие timestamp и сравниваем даты
                    if obj:
                        ts = obj.get("@timestamp")
                        if ts and ts.split("T")[0] != filter_date:
                            # Пропускаем строки не подходящие под фильтр даты
                            continue

                # Возвращаем строку через генератор
                yield line
